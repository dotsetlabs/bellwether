import { describe, it, expect, beforeEach } from 'vitest';
import { generateAgentsMd, generateJsonReport } from '../../src/docs/generator.js';
import type { InterviewResult, ToolProfile, InterviewMetadata } from '../../src/interview/types.js';
import type { DiscoveryResult } from '../../src/discovery/types.js';
import {
  weatherTool,
  calculatorTool,
  samplePrompts,
  mockServerInfo,
  mockCapabilities,
} from '../fixtures/sample-tools.js';

describe('docs/generator', () => {
  let mockDiscovery: DiscoveryResult;
  let mockToolProfile: ToolProfile;
  let mockMetadata: InterviewMetadata;
  let mockResult: InterviewResult;

  beforeEach(() => {
    const now = new Date('2024-01-15T10:30:00Z');

    mockDiscovery = {
      serverInfo: mockServerInfo,
      protocolVersion: '2024-11-05',
      capabilities: { tools: {}, prompts: {} },
      tools: [weatherTool, calculatorTool],
      prompts: samplePrompts,
      timestamp: now,
      serverCommand: 'npx test-server',
      serverArgs: ['--port', '3000'],
    };

    mockToolProfile = {
      name: 'get_weather',
      description: 'Get the current weather for a location',
      interactions: [],
      behavioralNotes: ['Responds quickly to valid inputs', 'Returns structured JSON'],
      limitations: ['Does not support batch queries'],
      securityNotes: ['No authentication required'],
    };

    mockMetadata = {
      startTime: now,
      endTime: new Date(now.getTime() + 5000),
      durationMs: 5000,
      toolCallCount: 10,
      errorCount: 2,
      model: 'gpt-4o',
    };

    mockResult = {
      discovery: mockDiscovery,
      toolProfiles: [mockToolProfile],
      summary: 'A weather service that provides current conditions for any location.',
      limitations: ['Rate limited to 100 requests per minute'],
      recommendations: ['Cache responses for frequently queried locations'],
      metadata: mockMetadata,
    };
  });

  describe('generateAgentsMd', () => {
    it('should generate header with server name', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('# test-server');
    });

    it('should include generation timestamp', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('Generated by [Bellwether]');
      expect(md).toContain('2024-01-15');
    });

    it('should include overview section with summary', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Overview');
      expect(md).toContain('A weather service that provides current conditions');
    });

    it('should include server and protocol versions', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('**Server Version:** 1.0.0');
      expect(md).toContain('**Protocol Version:** 2024-11-05');
    });

    it('should include capabilities section', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Capabilities');
      expect(md).toContain('**Tools:** 2 available');
      expect(md).toContain('**Prompts:** 2 available');
    });

    it('should show resources capability when present', () => {
      mockResult.discovery.capabilities = { ...mockCapabilities, resources: {} };
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('**Resources:** Supported');
    });

    it('should show logging capability when present', () => {
      mockResult.discovery.capabilities = { ...mockCapabilities, logging: {} };
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('**Logging:** Supported');
    });

    it('should include tools section with profiles', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Tools');
      expect(md).toContain('### get_weather');
      expect(md).toContain('Get the current weather for a location');
    });

    it('should include input schema for tools', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('**Input Schema:**');
      expect(md).toContain('```json');
      expect(md).toContain('"location"');
    });

    it('should include behavioral notes', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('**Observed Behavior:**');
      expect(md).toContain('- Responds quickly to valid inputs');
      expect(md).toContain('- Returns structured JSON');
    });

    it('should include tool limitations', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('**Limitations:**');
      expect(md).toContain('- Does not support batch queries');
    });

    it('should include security notes', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('**Security Considerations:**');
      expect(md).toContain('- No authentication required');
    });

    it('should include prompts section', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Prompts');
      expect(md).toContain('### summarize');
      expect(md).toContain('Summarize the given text');
    });

    it('should include prompt arguments', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('**Arguments:**');
      expect(md).toContain('`text`');
      expect(md).toContain('(required)');
    });

    it('should include overall limitations section', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Known Limitations');
      expect(md).toContain('- Rate limited to 100 requests per minute');
    });

    it('should include recommendations section', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Recommendations');
      expect(md).toContain('- Cache responses for frequently queried locations');
    });

    it('should include metadata footer', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('---');
      expect(md).toContain('Interview completed in');
      expect(md).toContain('5.0s');
      expect(md).toContain('10 tool calls');
      expect(md).toContain('2 errors');
    });

    it('should handle empty tool profiles', () => {
      mockResult.toolProfiles = [];
      const md = generateAgentsMd(mockResult);

      expect(md).not.toContain('## Tools');
    });

    it('should handle empty prompts', () => {
      mockResult.discovery.prompts = [];
      mockResult.discovery.capabilities = { tools: {} };
      const md = generateAgentsMd(mockResult);

      expect(md).not.toContain('## Prompts');
    });

    it('should handle empty limitations', () => {
      mockResult.limitations = [];
      const md = generateAgentsMd(mockResult);

      expect(md).not.toContain('## Known Limitations');
    });

    it('should handle empty recommendations', () => {
      mockResult.recommendations = [];
      const md = generateAgentsMd(mockResult);

      expect(md).not.toContain('## Recommendations');
    });

    it('should format milliseconds correctly', () => {
      mockResult.metadata.durationMs = 500;
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('500ms');
    });

    it('should format seconds correctly', () => {
      mockResult.metadata.durationMs = 30000;
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('30.0s');
    });

    it('should format minutes correctly', () => {
      mockResult.metadata.durationMs = 125000; // 2m 5s
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('2m 5s');
    });

    it('should handle tool with no behavioral notes', () => {
      mockResult.toolProfiles[0].behavioralNotes = [];
      const md = generateAgentsMd(mockResult);

      expect(md).not.toContain('**Observed Behavior:**');
    });

    it('should handle tool with no limitations', () => {
      mockResult.toolProfiles[0].limitations = [];
      const md = generateAgentsMd(mockResult);

      // Should not have limitations for this specific tool
      const toolSection = md.split('### get_weather')[1]?.split('###')[0] ?? '';
      expect(toolSection).not.toContain('**Limitations:**');
    });

    it('should handle tool with no security notes', () => {
      mockResult.toolProfiles[0].securityNotes = [];
      const md = generateAgentsMd(mockResult);

      const toolSection = md.split('### get_weather')[1]?.split('###')[0] ?? '';
      expect(toolSection).not.toContain('**Security Considerations:**');
    });
  });

  describe('generateJsonReport', () => {
    it('should generate valid JSON', () => {
      const json = generateJsonReport(mockResult);
      const parsed = JSON.parse(json);

      expect(parsed).toBeDefined();
    });

    it('should include all result data', () => {
      const json = generateJsonReport(mockResult);
      const parsed = JSON.parse(json);

      expect(parsed.discovery).toBeDefined();
      expect(parsed.toolProfiles).toBeDefined();
      expect(parsed.summary).toBeDefined();
      expect(parsed.limitations).toBeDefined();
      expect(parsed.recommendations).toBeDefined();
      expect(parsed.metadata).toBeDefined();
    });

    it('should preserve tool profiles', () => {
      const json = generateJsonReport(mockResult);
      const parsed = JSON.parse(json);

      expect(parsed.toolProfiles[0].name).toBe('get_weather');
      expect(parsed.toolProfiles[0].behavioralNotes).toContain('Responds quickly to valid inputs');
    });

    it('should preserve metadata', () => {
      const json = generateJsonReport(mockResult);
      const parsed = JSON.parse(json);

      expect(parsed.metadata.toolCallCount).toBe(10);
      expect(parsed.metadata.errorCount).toBe(2);
      expect(parsed.metadata.model).toBe('gpt-4o');
    });

    it('should be pretty-printed', () => {
      const json = generateJsonReport(mockResult);

      // Pretty-printed JSON should have newlines and indentation
      expect(json).toContain('\n');
      expect(json).toMatch(/\n\s{2}/);
    });
  });

  describe('Enhanced AGENTS.md Features (Phase 4)', () => {
    it('should include Quick Reference section', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Quick Reference');
      expect(md).toContain('| Tool | Parameters | Returns |');
    });

    it('should include tool parameters in Quick Reference', () => {
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('`get_weather`');
    });

    it('should include Example Usage section when there are successful interactions', () => {
      // Add a successful interaction to the tool profile
      mockResult.toolProfiles[0].interactions = [
        {
          toolName: 'get_weather',
          question: {
            description: 'Test weather lookup',
            category: 'happy_path',
            args: { location: 'New York', units: 'celsius' },
          },
          response: {
            content: [{ type: 'text', text: '{"temperature": 72}' }],
            isError: false,
          },
          error: null,
          analysis: 'Returns weather data',
          durationMs: 100,
        },
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).toContain('### Example Usage');
      expect(md).toContain('```json');
      expect(md).toContain('"location": "New York"');
    });

    it('should NOT include Example Usage section when all interactions failed', () => {
      // Only failed interactions
      mockResult.toolProfiles[0].interactions = [
        {
          toolName: 'get_weather',
          question: {
            description: 'Failed test',
            category: 'error_handling',
            args: { location: '' },
          },
          response: null,
          error: 'Invalid location',
          analysis: 'Failed',
          durationMs: 100,
        },
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).not.toContain('### Example Usage');
    });

    it('should include Security Considerations section when tools have security notes', () => {
      mockResult.toolProfiles[0].securityNotes = ['SQL injection risk', 'Data exposure possible'];
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Security Considerations');
    });

    it('should classify security findings by severity', () => {
      mockResult.toolProfiles[0].securityNotes = [
        'SQL injection vulnerability found',
        'Potential data leak risk',
        'Uses standard authentication',
      ];
      const md = generateAgentsMd(mockResult);

      expect(md).toContain('### Critical Issues');
      expect(md).toContain('### Warnings');
      expect(md).toContain('### Informational');
    });

    it('should not include Security section when no security notes', () => {
      mockResult.toolProfiles[0].securityNotes = [];
      const md = generateAgentsMd(mockResult);

      // Should not have the standalone Security Considerations section
      // (but individual tools may still have their own security notes)
      const quickRefIndex = md.indexOf('## Quick Reference');
      const toolsIndex = md.indexOf('## Tools');
      const beforeTools = md.slice(quickRefIndex, toolsIndex);

      expect(beforeTools).not.toContain('### Critical Issues');
    });

    it('should include Common Workflows section when successful workflows exist', () => {
      mockResult.workflowResults = [
        {
          workflow: {
            id: 'wf1',
            name: 'Weather Check',
            description: 'Get weather for a location',
            steps: [
              { tool: 'get_location', description: 'Get location' },
              { tool: 'get_weather', description: 'Get weather' },
            ],
            expectedOutcome: 'Weather data',
          },
          steps: [
            { step: { tool: 'get_location', description: 'Get location' }, success: true, analysis: 'OK' },
            { step: { tool: 'get_weather', description: 'Get weather' }, success: true, analysis: 'OK' },
          ],
          success: true,
          summary: 'Workflow completed',
        },
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Common Workflows');
      expect(md).toContain('Weather Check');
      expect(md).toContain('**Tool Sequence:**');
    });

    it('should include mermaid diagrams for workflows', () => {
      mockResult.workflowResults = [
        {
          workflow: {
            id: 'wf1',
            name: 'Test Workflow',
            description: 'Test',
            steps: [
              { tool: 'tool_a', description: 'Step A' },
              { tool: 'tool_b', description: 'Step B' },
            ],
            expectedOutcome: '',
          },
          steps: [
            { step: { tool: 'tool_a', description: 'Step A' }, success: true },
            { step: { tool: 'tool_b', description: 'Step B' }, success: true },
          ],
          success: true,
        },
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).toContain('```mermaid');
      expect(md).toContain('flowchart LR');
    });

    it('should include Workflow Test Results section', () => {
      mockResult.workflowResults = [
        {
          workflow: {
            id: 'wf1',
            name: 'Test Workflow',
            description: 'Test',
            steps: [{ tool: 'test', description: 'Test step' }],
            expectedOutcome: '',
          },
          steps: [{ step: { tool: 'test', description: 'Test step' }, success: false, error: 'Failed' }],
          success: false,
          failureReason: 'Step failed',
        },
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Workflow Test Results');
      expect(md).toContain('âŒ');
    });

    it('should include Behavioral Matrix when multiple personas used', () => {
      mockResult.metadata.personas = [
        { id: 'tech', name: 'Technical Writer', questionsAsked: 5, toolCallCount: 10, errorCount: 0 },
        { id: 'sec', name: 'Security Tester', questionsAsked: 3, toolCallCount: 8, errorCount: 1 },
      ];

      mockResult.toolProfiles[0].findingsByPersona = [
        {
          personaId: 'tech',
          personaName: 'Technical Writer',
          behavioralNotes: ['Note 1'],
          limitations: [],
          securityNotes: [],
        },
        {
          personaId: 'sec',
          personaName: 'Security Tester',
          behavioralNotes: [],
          limitations: ['Limitation 1'],
          securityNotes: ['Security note 1'],
        },
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).toContain('## Behavioral Matrix');
      expect(md).toContain('| Tool | Technical Writer | Security Tester |');
    });

    it('should not include Behavioral Matrix with single persona', () => {
      mockResult.metadata.personas = [
        { id: 'tech', name: 'Technical Writer', questionsAsked: 5, toolCallCount: 10, errorCount: 0 },
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).not.toContain('## Behavioral Matrix');
    });

    it('should include data flow diagrams in workflow test results', () => {
      mockResult.workflowResults = [
        {
          workflow: {
            id: 'wf1',
            name: 'Test Workflow',
            description: 'Test',
            steps: [
              { tool: 'tool_a', description: 'Step A' },
              { tool: 'tool_b', description: 'Step B' },
            ],
            expectedOutcome: '',
          },
          steps: [
            { step: { tool: 'tool_a', description: 'Step A' }, success: true },
            { step: { tool: 'tool_b', description: 'Step B' }, success: true },
          ],
          success: true,
          dataFlow: [
            { fromStep: 0, toStep: 1, sourcePath: 'result.id', targetParam: 'id' },
          ],
        },
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).toContain('**Data Flow:**');
      expect(md).toContain('classDef success');
      expect(md).toContain('classDef failure');
    });

    it('should show configuration warning when high error rate with access errors', () => {
      // Set up high error rate (>70%)
      mockResult.metadata.toolCallCount = 10;
      mockResult.metadata.errorCount = 9;

      // Add interactions with access-denied errors
      mockResult.toolProfiles[0].interactions = [
        {
          toolName: 'get_weather',
          question: { description: 'Test', category: 'happy_path', args: { path: '/etc/passwd' } },
          response: { content: [{ type: 'text', text: 'Access denied - path outside allowed directories' }], isError: true },
          error: null,
          analysis: 'Access denied',
          durationMs: 100,
        },
        {
          toolName: 'get_weather',
          question: { description: 'Test 2', category: 'happy_path', args: { path: '/root' } },
          response: { content: [{ type: 'text', text: 'Cannot read files outside predefined directories' }], isError: true },
          error: null,
          analysis: 'Denied',
          durationMs: 100,
        },
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).toContain('Configuration Issue Detected');
      expect(md).toContain('server may not have been configured with allowed directories');
    });

    it('should NOT show configuration warning when error rate is low', () => {
      // Set up low error rate (<70%)
      mockResult.metadata.toolCallCount = 10;
      mockResult.metadata.errorCount = 2;

      const md = generateAgentsMd(mockResult);

      expect(md).not.toContain('Configuration Issue Detected');
    });

    it('should show configuration warning based on limitations when error rate is very high', () => {
      // Set up very high error rate (>80%)
      mockResult.metadata.toolCallCount = 10;
      mockResult.metadata.errorCount = 9;

      // Add access-related limitations (without relying on interactions)
      mockResult.toolProfiles[0].limitations = [
        'Cannot read files outside predefined directories',
        'Access restricted to allowed directories only',
        'Cannot access paths outside allowed directories',
      ];

      const md = generateAgentsMd(mockResult);

      expect(md).toContain('Configuration Issue Detected');
    });
  });
});
