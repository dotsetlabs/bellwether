/**
 * Auto-generated test scenario generation from schema analysis.
 *
 * This module analyzes tool schemas and generates comprehensive test scenarios
 * covering happy paths, edge cases, error handling, and security testing.
 */

import { SCENARIO_GENERATION, ORCHESTRATOR } from '../constants.js';
import type { ToolFingerprint, BehavioralBaseline } from './types.js';
import { getToolFingerprints } from './accessors.js';
/**
 * Category of test scenario.
 */
export type ScenarioCategory = 'happy_path' | 'edge_cases' | 'error_handling' | 'security';

/**
 * Priority level for test scenarios.
 */
export type ScenarioPriority = 'critical' | 'high' | 'medium' | 'low';

/**
 * A single test scenario for a tool.
 */
export interface TestScenario {
  /** Unique identifier for the scenario */
  id: string;
  /** Name of the tool this scenario tests */
  toolName: string;
  /** Category of test scenario */
  category: ScenarioCategory;
  /** Human-readable description of what is being tested */
  description: string;
  /** The input to provide to the tool */
  input: Record<string, unknown>;
  /** Expected behavior or assertion */
  expectedBehavior: string;
  /** Priority level for execution order */
  priority: ScenarioPriority;
  /** Tags for filtering/grouping */
  tags: string[];
  /** Why this scenario was generated */
  rationale: string;
  /** Parameter(s) being tested */
  targetParameter?: string;
}

/**
 * Collection of auto-generated test scenarios for a tool.
 */
export interface AutoGeneratedScenarios {
  /** Tool being tested */
  toolName: string;
  /** Tool description for context */
  toolDescription: string;
  /** Success/valid input scenarios */
  happyPath: TestScenario[];
  /** Boundary conditions and unusual inputs */
  edgeCases: TestScenario[];
  /** Invalid input and error scenarios */
  errorCases: TestScenario[];
  /** Security-focused test cases */
  securityTests: TestScenario[];
  /** Total coverage percentage estimate */
  coverageEstimate: number;
  /** Parameters with generated scenarios */
  coveredParameters: string[];
  /** Parameters without scenarios (may need manual tests) */
  uncoveredParameters: string[];
  /** When scenarios were generated */
  generatedAt: Date;
}

/**
 * Summary of generated scenarios for an entire baseline.
 */
export interface ScenarioGenerationSummary {
  /** Total tools processed */
  toolsProcessed: number;
  /** Tools that got scenarios generated */
  toolsWithScenarios: number;
  /** Tools skipped (no schema, etc.) */
  toolsSkipped: number;
  /** Total scenarios generated */
  totalScenarios: number;
  /** Breakdown by category */
  scenariosByCategory: Record<ScenarioCategory, number>;
  /** Breakdown by priority */
  scenariosByPriority: Record<ScenarioPriority, number>;
  /** Average coverage estimate across tools */
  averageCoverage: number;
  /** Tools with low coverage that need attention */
  lowCoverageTools: string[];
  /** Generated timestamp */
  generatedAt: Date;
}

/**
 * Result of scenario generation for a baseline.
 */
export interface ScenarioGenerationResult {
  /** Per-tool scenario collections */
  scenarios: AutoGeneratedScenarios[];
  /** Overall summary */
  summary: ScenarioGenerationSummary;
}

/**
 * Configuration for scenario generation.
 */
export interface ScenarioGenerationConfig {
  /** Maximum happy path scenarios per tool */
  maxHappyPath?: number;
  /** Maximum edge case scenarios per tool */
  maxEdgeCases?: number;
  /** Maximum error case scenarios per tool */
  maxErrorCases?: number;
  /** Maximum security scenarios per tool */
  maxSecurityScenarios?: number;
  /** Minimum coverage to aim for */
  minCoverage?: number;
  /** Categories to generate (defaults to all) */
  categories?: ScenarioCategory[];
  /** Specific tools to generate for (defaults to all) */
  tools?: string[];
  /** Include security payloads for injection testing */
  includeSecurityPayloads?: boolean;
}
interface SchemaProperty {
  name: string;
  type: string;
  required: boolean;
  enum?: unknown[];
  minimum?: number;
  maximum?: number;
  minLength?: number;
  maxLength?: number;
  pattern?: string;
  format?: string;
  default?: unknown;
  items?: SchemaProperty;
  description?: string;
}

/**
 * Extract properties from a JSON schema.
 */
function extractSchemaProperties(schema: Record<string, unknown>): SchemaProperty[] {
  const properties: SchemaProperty[] = [];
  const schemaProps = schema.properties as Record<string, Record<string, unknown>> | undefined;
  const required = (schema.required as string[]) || [];

  if (!schemaProps) {
    return properties;
  }

  for (const [name, prop] of Object.entries(schemaProps)) {
    const property: SchemaProperty = {
      name,
      type: (prop.type as string) || 'unknown',
      required: required.includes(name),
      description: prop.description as string | undefined,
    };

    // Extract constraints
    if (prop.enum) property.enum = prop.enum as unknown[];
    if (typeof prop.minimum === 'number') property.minimum = prop.minimum;
    if (typeof prop.maximum === 'number') property.maximum = prop.maximum;
    if (typeof prop.minLength === 'number') property.minLength = prop.minLength;
    if (typeof prop.maxLength === 'number') property.maxLength = prop.maxLength;
    if (prop.pattern) property.pattern = prop.pattern as string;
    if (prop.format) property.format = prop.format as string;
    if (prop.default !== undefined) property.default = prop.default;

    // Handle array items
    if (prop.type === 'array' && prop.items) {
      const items = prop.items as Record<string, unknown>;
      property.items = {
        name: `${name}[]`,
        type: (items.type as string) || 'unknown',
        required: false,
      };
    }

    properties.push(property);
  }

  return properties;
}

/**
 * Generate a valid value for a schema property.
 */
function generateValidValue(prop: SchemaProperty): unknown {
  // Use default if available
  if (prop.default !== undefined) {
    return prop.default;
  }

  // Use first enum value if available
  if (prop.enum && prop.enum.length > 0) {
    return prop.enum[0];
  }

  // Generate based on type
  switch (prop.type) {
    case 'string':
      if (prop.format === 'email') return 'test@example.com';
      if (prop.format === 'uri' || prop.format === 'url') return 'https://example.com';
      if (prop.format === 'date') return '2025-01-15';
      if (prop.format === 'date-time') return '2025-01-15T10:30:00Z';
      if (prop.format === 'uuid') return '550e8400-e29b-41d4-a716-446655440000';
      if (prop.pattern) return generateFromPattern(prop.pattern);
      if (prop.minLength) return 'a'.repeat(prop.minLength);
      return 'test-value';

    case 'number':
    case 'integer':
      if (prop.minimum !== undefined && prop.maximum !== undefined) {
        return Math.floor((prop.minimum + prop.maximum) / 2);
      }
      if (prop.minimum !== undefined) return prop.minimum;
      if (prop.maximum !== undefined) return Math.min(prop.maximum, 100);
      return prop.type === 'integer' ? 42 : 42.5;

    case 'boolean':
      return true;

    case 'array':
      if (prop.items) {
        return [generateValidValue(prop.items)];
      }
      return [];

    case 'object':
      return {};

    default:
      return null;
  }
}

/**
 * Generate a simple value matching a regex pattern.
 */
function generateFromPattern(pattern: string): string {
  // Simple pattern matching for common cases
  if (pattern.includes('[a-z]')) return 'abc';
  if (pattern.includes('[A-Z]')) return 'ABC';
  if (pattern.includes('[0-9]') || pattern.includes('\\d')) return '123';
  if (pattern.includes('@')) return 'test@example.com';
  return 'pattern-value';
}

/**
 * Generate an invalid value for a schema property.
 */
function generateInvalidValue(prop: SchemaProperty): unknown {
  switch (prop.type) {
    case 'string':
      return 12345; // Number instead of string
    case 'number':
    case 'integer':
      return 'not-a-number';
    case 'boolean':
      return 'not-a-boolean';
    case 'array':
      return 'not-an-array';
    case 'object':
      return 'not-an-object';
    default:
      return Symbol('invalid');
  }
}

/**
 * Generate boundary values for a property.
 */
function generateBoundaryValues(prop: SchemaProperty): unknown[] {
  const values: unknown[] = [];

  switch (prop.type) {
    case 'string':
      if (prop.minLength !== undefined) {
        // At minimum
        values.push('a'.repeat(prop.minLength));
        // Just below minimum (if > 0)
        if (prop.minLength > 0) {
          values.push('a'.repeat(prop.minLength - 1));
        }
      }
      if (prop.maxLength !== undefined) {
        // At maximum
        values.push('a'.repeat(prop.maxLength));
        // Just above maximum
        values.push('a'.repeat(prop.maxLength + 1));
      }
      // Empty string
      values.push('');
      break;

    case 'number':
    case 'integer':
      if (prop.minimum !== undefined) {
        values.push(prop.minimum);
        values.push(prop.minimum - 1);
      }
      if (prop.maximum !== undefined) {
        values.push(prop.maximum);
        values.push(prop.maximum + 1);
      }
      // Zero and negative
      values.push(0);
      values.push(-1);
      // Very large number
      values.push(Number.MAX_SAFE_INTEGER);
      break;

    case 'array':
      values.push([]); // Empty array
      values.push([generateValidValue(prop.items || { name: 'item', type: 'string', required: false })]); // Single item
      break;
  }

  return values;
}
/**
 * Counter state for scenario ID generation.
 * Using an object to pass by reference through generator functions.
 */
interface CounterState {
  value: number;
}

/**
 * Generate a unique scenario ID using the provided counter state.
 */
function generateScenarioId(
  toolName: string,
  category: ScenarioCategory,
  counter: CounterState
): string {
  return `${toolName}-${category}-${++counter.value}`;
}

/**
 * Generate happy path scenarios for a tool.
 */
function generateHappyPathScenarios(
  tool: ToolFingerprint,
  properties: SchemaProperty[],
  maxScenarios: number,
  counter: CounterState
): TestScenario[] {
  const scenarios: TestScenario[] = [];

  // Scenario 1: All required parameters with valid values
  const requiredProps = properties.filter(p => p.required);
  if (requiredProps.length > 0 || properties.length > 0) {
    const input: Record<string, unknown> = {};
    const targetProps = requiredProps.length > 0 ? requiredProps : properties.slice(0, 3);

    for (const prop of targetProps) {
      input[prop.name] = generateValidValue(prop);
    }

    scenarios.push({
      id: generateScenarioId(tool.name, 'happy_path', counter),
      toolName: tool.name,
      category: 'happy_path',
      description: `Basic usage with ${requiredProps.length > 0 ? 'required' : 'minimal'} parameters`,
      input,
      expectedBehavior: 'Tool should execute successfully and return valid response',
      priority: 'critical',
      tags: ['basic', 'smoke-test'],
      rationale: 'Validates core functionality with minimal valid input',
    });
  }

  // Scenario 2: All parameters with valid values
  if (properties.length > requiredProps.length && scenarios.length < maxScenarios) {
    const input: Record<string, unknown> = {};
    for (const prop of properties) {
      input[prop.name] = generateValidValue(prop);
    }

    scenarios.push({
      id: generateScenarioId(tool.name, 'happy_path', counter),
      toolName: tool.name,
      category: 'happy_path',
      description: 'Full usage with all parameters',
      input,
      expectedBehavior: 'Tool should execute successfully with all options',
      priority: 'high',
      tags: ['full', 'comprehensive'],
      rationale: 'Validates all parameters work together correctly',
    });
  }

  // Scenario 3-N: Test different enum values
  for (const prop of properties) {
    if (prop.enum && prop.enum.length > 1 && scenarios.length < maxScenarios) {
      for (let i = 1; i < Math.min(prop.enum.length, ORCHESTRATOR.MAX_ENUM_TESTS + 1); i++) {
        if (scenarios.length >= maxScenarios) break;

        const input: Record<string, unknown> = {};
        // Set required params
        for (const p of properties.filter(p => p.required && p.name !== prop.name)) {
          input[p.name] = generateValidValue(p);
        }
        input[prop.name] = prop.enum[i];

        scenarios.push({
          id: generateScenarioId(tool.name, 'happy_path', counter),
          toolName: tool.name,
          category: 'happy_path',
          description: `Test ${prop.name} with value: ${JSON.stringify(prop.enum[i])}`,
          input,
          expectedBehavior: `Tool should handle ${prop.name}=${JSON.stringify(prop.enum[i])} correctly`,
          priority: 'medium',
          tags: ['enum', prop.name],
          rationale: `Validates enum value: ${JSON.stringify(prop.enum[i])}`,
          targetParameter: prop.name,
        });
      }
    }
  }

  // Scenario: Test with default values
  const propsWithDefaults = properties.filter(p => p.default !== undefined);
  if (propsWithDefaults.length > 0 && scenarios.length < maxScenarios) {
    const input: Record<string, unknown> = {};
    // Only set required params, let defaults apply
    for (const prop of properties.filter(p => p.required)) {
      input[prop.name] = generateValidValue(prop);
    }

    scenarios.push({
      id: generateScenarioId(tool.name, 'happy_path', counter),
      toolName: tool.name,
      category: 'happy_path',
      description: 'Test with default values applied',
      input,
      expectedBehavior: 'Tool should apply defaults correctly',
      priority: 'medium',
      tags: ['defaults'],
      rationale: `Tests default value behavior for: ${propsWithDefaults.map(p => p.name).join(', ')}`,
    });
  }

  return scenarios.slice(0, maxScenarios);
}

/**
 * Generate edge case scenarios for a tool.
 */
function generateEdgeCaseScenarios(
  tool: ToolFingerprint,
  properties: SchemaProperty[],
  maxScenarios: number,
  counter: CounterState
): TestScenario[] {
  const scenarios: TestScenario[] = [];

  for (const prop of properties) {
    if (scenarios.length >= maxScenarios) break;

    const boundaryValues = generateBoundaryValues(prop);

    for (const value of boundaryValues) {
      if (scenarios.length >= maxScenarios) break;

      const input: Record<string, unknown> = {};
      // Set required params
      for (const p of properties.filter(p => p.required && p.name !== prop.name)) {
        input[p.name] = generateValidValue(p);
      }
      input[prop.name] = value;

      const isInvalid = isBoundaryValueInvalid(prop, value);

      scenarios.push({
        id: generateScenarioId(tool.name, 'edge_cases', counter),
        toolName: tool.name,
        category: 'edge_cases',
        description: `Boundary test: ${prop.name} = ${formatValue(value)}`,
        input,
        expectedBehavior: isInvalid
          ? `Tool should reject or handle invalid ${prop.name} gracefully`
          : `Tool should handle boundary value for ${prop.name}`,
        priority: isInvalid ? 'high' : 'medium',
        tags: ['boundary', prop.name, isInvalid ? 'invalid' : 'valid'],
        rationale: `Tests ${prop.name} at boundary: ${formatValue(value)}`,
        targetParameter: prop.name,
      });
    }
  }

  // Add empty object test
  if (scenarios.length < maxScenarios) {
    const requiredProps = properties.filter(p => p.required);
    if (requiredProps.length === 0) {
      scenarios.push({
        id: generateScenarioId(tool.name, 'edge_cases', counter),
        toolName: tool.name,
        category: 'edge_cases',
        description: 'Empty input (no parameters)',
        input: {},
        expectedBehavior: 'Tool should handle empty input gracefully',
        priority: 'medium',
        tags: ['empty', 'minimal'],
        rationale: 'Tests behavior with no parameters provided',
      });
    }
  }

  // Add null/undefined tests for optional params
  const optionalProps = properties.filter(p => !p.required);
  for (const prop of optionalProps) {
    if (scenarios.length >= maxScenarios) break;

    const input: Record<string, unknown> = {};
    for (const p of properties.filter(p => p.required)) {
      input[p.name] = generateValidValue(p);
    }
    input[prop.name] = null;

    scenarios.push({
      id: generateScenarioId(tool.name, 'edge_cases', counter),
      toolName: tool.name,
      category: 'edge_cases',
      description: `Null value for optional: ${prop.name}`,
      input,
      expectedBehavior: `Tool should handle null ${prop.name} gracefully`,
      priority: 'low',
      tags: ['null', prop.name],
      rationale: 'Tests null handling for optional parameter',
      targetParameter: prop.name,
    });
  }

  return scenarios.slice(0, maxScenarios);
}

/**
 * Check if a boundary value is invalid according to the schema.
 */
function isBoundaryValueInvalid(prop: SchemaProperty, value: unknown): boolean {
  if (value === null || value === undefined) return true;

  switch (prop.type) {
    case 'string':
      if (typeof value !== 'string') return true;
      if (prop.minLength !== undefined && value.length < prop.minLength) return true;
      if (prop.maxLength !== undefined && value.length > prop.maxLength) return true;
      break;

    case 'number':
    case 'integer':
      if (typeof value !== 'number') return true;
      if (prop.minimum !== undefined && value < prop.minimum) return true;
      if (prop.maximum !== undefined && value > prop.maximum) return true;
      break;

    case 'array':
      if (!Array.isArray(value)) return true;
      break;
  }

  return false;
}

/**
 * Format a value for display.
 */
function formatValue(value: unknown): string {
  if (value === null) return 'null';
  if (value === undefined) return 'undefined';
  if (typeof value === 'string') {
    if (value.length > 30) return `"${value.substring(0, 27)}..."`;
    return `"${value}"`;
  }
  if (Array.isArray(value)) {
    if (value.length === 0) return '[]';
    return `[${value.length} items]`;
  }
  return String(value);
}

/**
 * Generate error case scenarios for a tool.
 */
function generateErrorCaseScenarios(
  tool: ToolFingerprint,
  properties: SchemaProperty[],
  maxScenarios: number,
  counter: CounterState
): TestScenario[] {
  const scenarios: TestScenario[] = [];

  // Test missing required parameters
  const requiredProps = properties.filter(p => p.required);
  for (const prop of requiredProps) {
    if (scenarios.length >= maxScenarios) break;

    const input: Record<string, unknown> = {};
    // Set all required except this one
    for (const p of requiredProps.filter(p => p.name !== prop.name)) {
      input[p.name] = generateValidValue(p);
    }

    scenarios.push({
      id: generateScenarioId(tool.name, 'error_handling', counter),
      toolName: tool.name,
      category: 'error_handling',
      description: `Missing required parameter: ${prop.name}`,
      input,
      expectedBehavior: `Tool should return error for missing ${prop.name}`,
      priority: 'critical',
      tags: ['missing-required', prop.name],
      rationale: 'Validates required parameter enforcement',
      targetParameter: prop.name,
    });
  }

  // Test invalid types
  for (const prop of properties) {
    if (scenarios.length >= maxScenarios) break;

    const input: Record<string, unknown> = {};
    // Set required params
    for (const p of properties.filter(p => p.required && p.name !== prop.name)) {
      input[p.name] = generateValidValue(p);
    }
    input[prop.name] = generateInvalidValue(prop);

    scenarios.push({
      id: generateScenarioId(tool.name, 'error_handling', counter),
      toolName: tool.name,
      category: 'error_handling',
      description: `Invalid type for ${prop.name}: expected ${prop.type}`,
      input,
      expectedBehavior: `Tool should reject invalid type for ${prop.name}`,
      priority: 'high',
      tags: ['invalid-type', prop.name],
      rationale: `Tests type validation for ${prop.name} (expected ${prop.type})`,
      targetParameter: prop.name,
    });
  }

  // Test invalid enum values
  for (const prop of properties.filter(p => p.enum)) {
    if (scenarios.length >= maxScenarios) break;

    const input: Record<string, unknown> = {};
    for (const p of properties.filter(p => p.required && p.name !== prop.name)) {
      input[p.name] = generateValidValue(p);
    }
    input[prop.name] = 'invalid-enum-value-xyz';

    scenarios.push({
      id: generateScenarioId(tool.name, 'error_handling', counter),
      toolName: tool.name,
      category: 'error_handling',
      description: `Invalid enum value for ${prop.name}`,
      input,
      expectedBehavior: `Tool should reject invalid enum value for ${prop.name}`,
      priority: 'high',
      tags: ['invalid-enum', prop.name],
      rationale: `Tests enum validation for ${prop.name}`,
      targetParameter: prop.name,
    });
  }

  return scenarios.slice(0, maxScenarios);
}

/**
 * Generate security test scenarios for a tool.
 */
function generateSecurityScenarios(
  tool: ToolFingerprint,
  properties: SchemaProperty[],
  maxScenarios: number,
  includePayloads: boolean,
  counter: CounterState
): TestScenario[] {
  const scenarios: TestScenario[] = [];

  const stringProps = properties.filter(p => p.type === 'string');

  if (!includePayloads || stringProps.length === 0) {
    return scenarios;
  }

  // SQL Injection tests
  for (const prop of stringProps) {
    if (scenarios.length >= maxScenarios) break;

    const payload = SCENARIO_GENERATION.SQL_INJECTION_PAYLOADS[0];
    const input: Record<string, unknown> = {};
    for (const p of properties.filter(p => p.required && p.name !== prop.name)) {
      input[p.name] = generateValidValue(p);
    }
    input[prop.name] = payload;

    scenarios.push({
      id: generateScenarioId(tool.name, 'security', counter),
      toolName: tool.name,
      category: 'security',
      description: `SQL injection test on ${prop.name}`,
      input,
      expectedBehavior: 'Tool should sanitize input and not execute SQL',
      priority: 'critical',
      tags: ['sql-injection', 'security', prop.name],
      rationale: 'Tests SQL injection vulnerability',
      targetParameter: prop.name,
    });
  }

  // XSS tests
  for (const prop of stringProps) {
    if (scenarios.length >= maxScenarios) break;

    const payload = SCENARIO_GENERATION.XSS_PAYLOADS[0];
    const input: Record<string, unknown> = {};
    for (const p of properties.filter(p => p.required && p.name !== prop.name)) {
      input[p.name] = generateValidValue(p);
    }
    input[prop.name] = payload;

    scenarios.push({
      id: generateScenarioId(tool.name, 'security', counter),
      toolName: tool.name,
      category: 'security',
      description: `XSS test on ${prop.name}`,
      input,
      expectedBehavior: 'Tool should sanitize or escape HTML/script content',
      priority: 'critical',
      tags: ['xss', 'security', prop.name],
      rationale: 'Tests cross-site scripting vulnerability',
      targetParameter: prop.name,
    });
  }

  // Path traversal tests (for file-related parameters)
  const fileProps = stringProps.filter(
    p =>
      p.name.toLowerCase().includes('path') ||
      p.name.toLowerCase().includes('file') ||
      p.name.toLowerCase().includes('dir') ||
      p.description?.toLowerCase().includes('path') ||
      p.description?.toLowerCase().includes('file')
  );

  for (const prop of fileProps) {
    if (scenarios.length >= maxScenarios) break;

    const payload = SCENARIO_GENERATION.PATH_TRAVERSAL_PAYLOADS[0];
    const input: Record<string, unknown> = {};
    for (const p of properties.filter(p => p.required && p.name !== prop.name)) {
      input[p.name] = generateValidValue(p);
    }
    input[prop.name] = payload;

    scenarios.push({
      id: generateScenarioId(tool.name, 'security', counter),
      toolName: tool.name,
      category: 'security',
      description: `Path traversal test on ${prop.name}`,
      input,
      expectedBehavior: 'Tool should reject path traversal attempts',
      priority: 'critical',
      tags: ['path-traversal', 'security', prop.name],
      rationale: 'Tests path traversal vulnerability',
      targetParameter: prop.name,
    });
  }

  // Command injection tests (for command-like parameters)
  const cmdProps = stringProps.filter(
    p =>
      p.name.toLowerCase().includes('command') ||
      p.name.toLowerCase().includes('cmd') ||
      p.name.toLowerCase().includes('exec') ||
      p.name.toLowerCase().includes('shell')
  );

  for (const prop of cmdProps) {
    if (scenarios.length >= maxScenarios) break;

    const input: Record<string, unknown> = {};
    for (const p of properties.filter(p => p.required && p.name !== prop.name)) {
      input[p.name] = generateValidValue(p);
    }
    input[prop.name] = '; rm -rf /';

    scenarios.push({
      id: generateScenarioId(tool.name, 'security', counter),
      toolName: tool.name,
      category: 'security',
      description: `Command injection test on ${prop.name}`,
      input,
      expectedBehavior: 'Tool should sanitize command input',
      priority: 'critical',
      tags: ['command-injection', 'security', prop.name],
      rationale: 'Tests command injection vulnerability',
      targetParameter: prop.name,
    });
  }

  return scenarios.slice(0, maxScenarios);
}
/**
 * Generate test scenarios for a single tool.
 */
export function generateToolScenarios(
  tool: ToolFingerprint,
  config: ScenarioGenerationConfig = {}
): AutoGeneratedScenarios {
  const {
    maxHappyPath = SCENARIO_GENERATION.MAX_HAPPY_PATH_SCENARIOS,
    maxEdgeCases = SCENARIO_GENERATION.MAX_EDGE_CASE_SCENARIOS,
    maxErrorCases = SCENARIO_GENERATION.MAX_ERROR_CASE_SCENARIOS,
    maxSecurityScenarios = SCENARIO_GENERATION.MAX_SECURITY_SCENARIOS,
    categories = SCENARIO_GENERATION.CATEGORIES as ScenarioCategory[],
    includeSecurityPayloads = true,
  } = config;

  // Counter for generating unique scenario IDs within this tool
  const counter: CounterState = { value: 0 };

  const properties = tool.inputSchema ? extractSchemaProperties(tool.inputSchema) : [];

  const happyPath = categories.includes('happy_path')
    ? generateHappyPathScenarios(tool, properties, maxHappyPath, counter)
    : [];

  const edgeCases = categories.includes('edge_cases')
    ? generateEdgeCaseScenarios(tool, properties, maxEdgeCases, counter)
    : [];

  const errorCases = categories.includes('error_handling')
    ? generateErrorCaseScenarios(tool, properties, maxErrorCases, counter)
    : [];

  const securityTests = categories.includes('security')
    ? generateSecurityScenarios(tool, properties, maxSecurityScenarios, includeSecurityPayloads, counter)
    : [];

  // Calculate coverage
  const totalScenarios = happyPath.length + edgeCases.length + errorCases.length + securityTests.length;
  const coveredParams = new Set<string>();

  for (const scenario of [...happyPath, ...edgeCases, ...errorCases, ...securityTests]) {
    if (scenario.targetParameter) {
      coveredParams.add(scenario.targetParameter);
    }
    // Also count parameters in input
    for (const param of Object.keys(scenario.input)) {
      coveredParams.add(param);
    }
  }

  const allParams = properties.map(p => p.name);
  const uncovered = allParams.filter(p => !coveredParams.has(p));

  // Estimate coverage based on parameters covered and scenario diversity
  let coverageEstimate = 0;
  if (allParams.length > 0) {
    const paramCoverage = (coveredParams.size / allParams.length) * 100;
    const categoryBonus = categories.length * 5; // Bonus for testing multiple categories
    coverageEstimate = Math.min(100, Math.round(paramCoverage + categoryBonus));
  } else if (totalScenarios > 0) {
    coverageEstimate = 50; // Basic coverage for tools without schema
  }

  return {
    toolName: tool.name,
    toolDescription: tool.description,
    happyPath,
    edgeCases,
    errorCases,
    securityTests,
    coverageEstimate,
    coveredParameters: Array.from(coveredParams),
    uncoveredParameters: uncovered,
    generatedAt: new Date(),
  };
}

/**
 * Generate test scenarios for all tools in a baseline.
 */
export function generateBaselineScenarios(
  baseline: BehavioralBaseline,
  config: ScenarioGenerationConfig = {}
): ScenarioGenerationResult {
  const { tools: targetTools, minCoverage = SCENARIO_GENERATION.DEFAULT_MIN_COVERAGE } = config;

  const baselineTools = getToolFingerprints(baseline);
  const toolsToProcess = targetTools
    ? baselineTools.filter(t => targetTools.includes(t.name))
    : baselineTools;

  const scenarios: AutoGeneratedScenarios[] = [];
  let toolsWithScenarios = 0;
  let toolsSkipped = 0;

  const categoryTotals: Record<ScenarioCategory, number> = {
    happy_path: 0,
    edge_cases: 0,
    error_handling: 0,
    security: 0,
  };

  const priorityTotals: Record<ScenarioPriority, number> = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
  };

  for (const tool of toolsToProcess) {
    // Skip tools without schema (can't generate meaningful scenarios)
    if (!tool.inputSchema) {
      toolsSkipped++;
      continue;
    }

    const toolScenarios = generateToolScenarios(tool, config);
    const totalForTool =
      toolScenarios.happyPath.length +
      toolScenarios.edgeCases.length +
      toolScenarios.errorCases.length +
      toolScenarios.securityTests.length;

    if (totalForTool > 0) {
      toolsWithScenarios++;
      scenarios.push(toolScenarios);

      // Update category totals
      categoryTotals.happy_path += toolScenarios.happyPath.length;
      categoryTotals.edge_cases += toolScenarios.edgeCases.length;
      categoryTotals.error_handling += toolScenarios.errorCases.length;
      categoryTotals.security += toolScenarios.securityTests.length;

      // Update priority totals
      for (const s of [
        ...toolScenarios.happyPath,
        ...toolScenarios.edgeCases,
        ...toolScenarios.errorCases,
        ...toolScenarios.securityTests,
      ]) {
        priorityTotals[s.priority]++;
      }
    } else {
      toolsSkipped++;
    }
  }

  const totalScenarios = Object.values(categoryTotals).reduce((a, b) => a + b, 0);
  const averageCoverage =
    scenarios.length > 0
      ? Math.round(scenarios.reduce((sum, s) => sum + s.coverageEstimate, 0) / scenarios.length)
      : 0;

  const lowCoverageTools = scenarios
    .filter(s => s.coverageEstimate < minCoverage)
    .map(s => s.toolName);

  return {
    scenarios,
    summary: {
      toolsProcessed: toolsToProcess.length,
      toolsWithScenarios,
      toolsSkipped,
      totalScenarios,
      scenariosByCategory: categoryTotals,
      scenariosByPriority: priorityTotals,
      averageCoverage,
      lowCoverageTools,
      generatedAt: new Date(),
    },
  };
}
/**
 * Format scenarios as YAML for test execution.
 */
export function formatScenariosAsYaml(result: ScenarioGenerationResult): string {
  const lines: string[] = [
    '# Auto-generated test scenarios',
    `# Generated: ${result.summary.generatedAt.toISOString()}`,
    `# Total scenarios: ${result.summary.totalScenarios}`,
    '',
    'scenarios:',
  ];

  for (const toolScenarios of result.scenarios) {
    lines.push(`  # Tool: ${toolScenarios.toolName}`);
    lines.push(`  # Coverage: ${toolScenarios.coverageEstimate}%`);

    const allScenarios = [
      ...toolScenarios.happyPath,
      ...toolScenarios.edgeCases,
      ...toolScenarios.errorCases,
      ...toolScenarios.securityTests,
    ];

    for (const scenario of allScenarios) {
      lines.push(`  - id: ${scenario.id}`);
      lines.push(`    tool: ${scenario.toolName}`);
      lines.push(`    category: ${scenario.category}`);
      lines.push(`    description: "${scenario.description.replace(/"/g, '\\"')}"`);
      lines.push(`    priority: ${scenario.priority}`);
      lines.push(`    input:`);

      for (const [key, value] of Object.entries(scenario.input)) {
        const yamlValue = formatYamlValue(value);
        lines.push(`      ${key}: ${yamlValue}`);
      }

      lines.push(`    expected: "${scenario.expectedBehavior.replace(/"/g, '\\"')}"`);
      lines.push(`    tags: [${scenario.tags.map(t => `"${t}"`).join(', ')}]`);
      lines.push('');
    }
  }

  return lines.join('\n');
}

/**
 * Format a value for YAML output.
 */
function formatYamlValue(value: unknown): string {
  if (value === null) return 'null';
  if (value === undefined) return 'null';
  if (typeof value === 'string') {
    // Escape special characters
    if (value.includes('\n') || value.includes('"') || value.includes(':')) {
      return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`;
    }
    return `"${value}"`;
  }
  if (typeof value === 'number' || typeof value === 'boolean') {
    return String(value);
  }
  if (Array.isArray(value)) {
    if (value.length === 0) return '[]';
    return `[${value.map(v => formatYamlValue(v)).join(', ')}]`;
  }
  if (typeof value === 'object') {
    return JSON.stringify(value);
  }
  return String(value);
}

/**
 * Format scenarios as a human-readable report.
 */
export function formatScenariosReport(result: ScenarioGenerationResult): string {
  const lines: string[] = [
    '═══════════════════════════════════════════════════════════════',
    '                 AUTO-GENERATED TEST SCENARIOS                  ',
    '═══════════════════════════════════════════════════════════════',
    '',
    `Generated: ${result.summary.generatedAt.toISOString()}`,
    '',
    '── Summary ──────────────────────────────────────────────────────',
    `  Tools processed:      ${result.summary.toolsProcessed}`,
    `  Tools with scenarios: ${result.summary.toolsWithScenarios}`,
    `  Tools skipped:        ${result.summary.toolsSkipped}`,
    `  Total scenarios:      ${result.summary.totalScenarios}`,
    `  Average coverage:     ${result.summary.averageCoverage}%`,
    '',
    '── By Category ──────────────────────────────────────────────────',
    `  Happy Path:     ${result.summary.scenariosByCategory.happy_path}`,
    `  Edge Cases:     ${result.summary.scenariosByCategory.edge_cases}`,
    `  Error Handling: ${result.summary.scenariosByCategory.error_handling}`,
    `  Security:       ${result.summary.scenariosByCategory.security}`,
    '',
    '── By Priority ──────────────────────────────────────────────────',
    `  Critical: ${result.summary.scenariosByPriority.critical}`,
    `  High:     ${result.summary.scenariosByPriority.high}`,
    `  Medium:   ${result.summary.scenariosByPriority.medium}`,
    `  Low:      ${result.summary.scenariosByPriority.low}`,
  ];

  if (result.summary.lowCoverageTools.length > 0) {
    lines.push('');
    lines.push('── Low Coverage Tools (need attention) ─────────────────────────');
    for (const tool of result.summary.lowCoverageTools) {
      const toolData = result.scenarios.find(s => s.toolName === tool);
      lines.push(`  • ${tool} (${toolData?.coverageEstimate ?? 0}%)`);
    }
  }

  lines.push('');
  lines.push('── Tool Details ─────────────────────────────────────────────────');

  for (const toolScenarios of result.scenarios) {
    const total =
      toolScenarios.happyPath.length +
      toolScenarios.edgeCases.length +
      toolScenarios.errorCases.length +
      toolScenarios.securityTests.length;

    lines.push('');
    lines.push(`  ${toolScenarios.toolName}`);
    lines.push(`    Scenarios: ${total} | Coverage: ${toolScenarios.coverageEstimate}%`);
    lines.push(
      `    HP: ${toolScenarios.happyPath.length} | EC: ${toolScenarios.edgeCases.length} | EH: ${toolScenarios.errorCases.length} | SEC: ${toolScenarios.securityTests.length}`
    );

    if (toolScenarios.uncoveredParameters.length > 0) {
      lines.push(`    Uncovered: ${toolScenarios.uncoveredParameters.join(', ')}`);
    }
  }

  lines.push('');
  lines.push('═══════════════════════════════════════════════════════════════');

  return lines.join('\n');
}

/**
 * Get scenarios filtered by priority.
 */
export function getScenariosByPriority(
  result: ScenarioGenerationResult,
  priority: ScenarioPriority
): TestScenario[] {
  const allScenarios: TestScenario[] = [];

  for (const toolScenarios of result.scenarios) {
    allScenarios.push(
      ...toolScenarios.happyPath.filter(s => s.priority === priority),
      ...toolScenarios.edgeCases.filter(s => s.priority === priority),
      ...toolScenarios.errorCases.filter(s => s.priority === priority),
      ...toolScenarios.securityTests.filter(s => s.priority === priority)
    );
  }

  return allScenarios;
}

/**
 * Get scenarios filtered by category.
 */
export function getScenariosByCategory(
  result: ScenarioGenerationResult,
  category: ScenarioCategory
): TestScenario[] {
  const allScenarios: TestScenario[] = [];

  for (const toolScenarios of result.scenarios) {
    switch (category) {
      case 'happy_path':
        allScenarios.push(...toolScenarios.happyPath);
        break;
      case 'edge_cases':
        allScenarios.push(...toolScenarios.edgeCases);
        break;
      case 'error_handling':
        allScenarios.push(...toolScenarios.errorCases);
        break;
      case 'security':
        allScenarios.push(...toolScenarios.securityTests);
        break;
    }
  }

  return allScenarios;
}

/**
 * Get critical scenarios for smoke testing.
 */
export function getCriticalScenarios(result: ScenarioGenerationResult): TestScenario[] {
  return getScenariosByPriority(result, 'critical');
}

/**
 * Get security-focused scenarios.
 */
export function getSecurityScenarios(result: ScenarioGenerationResult): TestScenario[] {
  return getScenariosByCategory(result, 'security');
}
